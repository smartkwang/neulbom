<!DOCTYPE html>
<html lang="ko">
<head>
    <!-- ... (기존 head 내용 유지) ... -->
    <style>
        /* ... (기존 style 내용 유지) ... */
        /* 로딩 중 슬롯 클릭 방지용 스타일 추가 */
        .pointer-events-none {
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gray-50">
    <!-- ... (기존 body 상단 내용 유지) ... -->

<script>
    document.addEventListener('DOMContentLoaded', function() {
        // --- ★★★ 중요 설정 ★★★ ---
        // 1. 본인의 배포된 웹 앱 URL로 반드시 교체하세요!
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbz6PebnLrnFdr1mANk03jlUn5ldl2Llj1CF7S-cSn49bNIcPZuB2_y1UjCaHr4ZNlJf3Q/exec';
        // 2. 각 슬롯별 총 정원 (Apps Script doPost 함수의 capacity와 일치시켜야 함)
        const totalCapacity = 20;
        // --- 설정 끝 ---


        // DOM 요소 참조 (기존과 동일)
        const form = document.getElementById('registrationForm');
        // ... (다른 요소 참조들) ...
        const successModal = document.getElementById('successModal');
        const errorModal = document.getElementById('errorModal');
        const successMessageEl = document.getElementById('successMessage');
        const errorMessageEl = document.getElementById('errorMessage');


        // 로컬 데이터 저장용 (기존과 동일, 슬롯 정의가 Apps Script allSlots와 일치해야 함)
        let reservations = JSON.parse(localStorage.getItem('eventReservations')) || initializeReservationsObject();

        function initializeReservationsObject() {
             // ★★★ 이 부분의 날짜와 시간이 Apps Script의 allSlots와 정확히 일치해야 합니다. ★★★
            return {
                '2025-05-22': {'09:30-10:00': [], '10:00-10:30': [], '10:30-11:00': [], '11:00-11:30': [], '11:30-12:00': []},
                '2025-05-23': {'09:30-10:00': [], '10:00-10:30': [], '10:30-11:00': [], '11:00-11:30': [], '11:30-12:00': []},
                '2025-05-30': {'09:30-10:00': [], '10:00-10:30': [], '10:30-11:00': [], '11:00-11:30': [], '11:30-12:00': []}
            };
        }

        // 서버 카운트를 로컬 reservations 객체로 변환 (기존과 동일)
        function updateReservationsFromCounts(serverCounts) {
             reservations = initializeReservationsObject(); // 초기화 먼저
             for (const date in serverCounts) {
                 if (reservations.hasOwnProperty(date)) { // 로컬 정의된 날짜인지 확인
                     for (const time in serverCounts[date]) {
                         if (reservations[date].hasOwnProperty(time)) { // 로컬 정의된 시간인지 확인
                             const count = parseInt(serverCounts[date][time] || 0, 10);
                             // 유효한 숫자인지 확인 후 배열 생성
                             if (!isNaN(count) && count >= 0) {
                                 reservations[date][time] = new Array(count).fill(null);
                             } else {
                                 console.warn(`서버에서 받은 ${date} ${time}의 카운트 값이 유효하지 않습니다: ${serverCounts[date][time]}. 0으로 처리합니다.`);
                                 reservations[date][time] = []; // 유효하지 않으면 빈 배열로
                             }
                         } else {
                             console.warn(`서버 응답에 정의되지 않은 시간 슬롯 포함: ${date} - ${time}`);
                         }
                     }
                 } else {
                      console.warn(`서버 응답에 정의되지 않은 날짜 포함: ${date}`);
                 }
             }
             console.log("로컬 reservations 객체 업데이트 완료:", JSON.parse(JSON.stringify(reservations)));
         }


        // 슬롯 임시 비활성화/활성화 (클래스명 수정 반영)
        function disableAllSlotsTemporarily(disable) {
            document.querySelectorAll('.time-slot').forEach(slot => {
                if (disable) {
                    slot.classList.add('opacity-50', 'pointer-events-none'); // 클릭 불가 스타일 추가
                } else {
                    slot.classList.remove('opacity-50', 'pointer-events-none');
                }
            });
        }

        // 슬롯 UI 업데이트 (totalCapacity 상수 사용하도록 수정)
        function updateSlotStatus() {
             console.log("UI 업데이트 시작.");
             // const totalCapacity = 20; // ★★★ 상수로 이동함 ★★★

             document.querySelectorAll('.time-slot').forEach(slot => {
                 const date = slot.getAttribute('data-date');
                 const time = slot.getAttribute('data-time');
                 let registeredCount = 0;

                 // reservations 객체에서 해당 슬롯의 예약 수 확인 (안전하게 확인)
                 if (reservations.hasOwnProperty(date) && reservations[date].hasOwnProperty(time)) {
                     registeredCount = reservations[date][time].length;
                 } else {
                     console.warn(`UI 업데이트 중 정의되지 않은 슬롯 발견: ${date} ${time}`);
                 }

                 const remaining = Math.max(0, totalCapacity - registeredCount); // 음수 방지
                 // 퍼센티지 계산 시 totalCapacity가 0인 경우 방지
                 const percentage = totalCapacity > 0 ? Math.max(0, Math.min(100, (registeredCount / totalCapacity) * 100)) : 0;

                 // UI 요소 업데이트
                 const remainingCountEl = slot.querySelector('.remaining-count');
                 const totalCountEl = slot.querySelector('.total-count');
                 const progressBarFill = slot.querySelector('.progress-fill');
                 const slotStatusBadge = slot.querySelector('.slot-status');

                 // 요소 존재 여부 확인 후 업데이트
                 if (remainingCountEl) remainingCountEl.textContent = remaining;
                 if (totalCountEl) totalCountEl.textContent = totalCapacity; // 상수로 업데이트
                 if (progressBarFill) progressBarFill.style.width = `${percentage}%`;

                 // 상태별 스타일링 (기존 로직 유지, 약간 정리)
                 slot.classList.remove('disabled'); // selected는 클릭 시 관리되므로 여기서 제거 안 함
                 if (slotStatusBadge) {
                      slotStatusBadge.className = 'slot-status text-sm py-1 px-2 rounded-full'; // 기본 클래스 재설정 후 추가
                 }
                 if (progressBarFill) progressBarFill.style.backgroundColor = '#4F46E5'; // 기본 인디고

                 if (remaining <= 0) {
                     slot.classList.add('disabled'); // 마감 시 비활성화
                     if (slotStatusBadge) slotStatusBadge.classList.add('bg-red-100', 'text-red-800');
                     if (progressBarFill) progressBarFill.style.backgroundColor = '#EF4444';
                 } else if (remaining <= 5) { // 마감 임박
                     if (slotStatusBadge) slotStatusBadge.classList.add('bg-yellow-100', 'text-yellow-800');
                     if (progressBarFill) progressBarFill.style.backgroundColor = '#F59E0B';
                 } else { // 여유 있음
                     if (slotStatusBadge) slotStatusBadge.classList.add('bg-green-100', 'text-green-800');
                 }

                 // 현재 선택된 슬롯 스타일 유지 (선택 해제 로직은 클릭 핸들러에 있음)
                 const selectedDT = document.getElementById('selectedDateTime').value;
                 if (`${date} ${time}` === selectedDT) {
                     slot.classList.add('selected');
                 } else {
                     slot.classList.remove('selected'); // 명시적으로 선택 해제
                 }
             });
             console.log("UI 업데이트 완료.");
         }


        // 서버에서 최신 예약 현황 가져오기 (fetchAndUpdateCounts)
        function fetchAndUpdateCounts() {
            console.log("서버에서 최신 예약 현황 가져오는 중...");
            if (!SCRIPT_URL || SCRIPT_URL === '여기에_배포된_웹_앱_URL을_붙여넣으세요') {
                 console.error("스크립트 URL이 설정되지 않았습니다!");
                 errorMessageEl.textContent = "시스템 설정 오류입니다. 관리자에게 문의하세요. (URL 미설정)";
                 errorModal.classList.remove('hidden');
                 // 로컬 데이터 기반으로 일단 UI 그림
                 reservations = JSON.parse(localStorage.getItem('eventReservations')) || initializeReservationsObject();
                 updateSlotStatus();
                 return; // 함수 종료
            }

            document.body.style.cursor = 'wait';
            disableAllSlotsTemporarily(true); // 슬롯 비활성화

            fetch(SCRIPT_URL + "?action=getCounts")
                .then(response => {
                    if (!response.ok) {
                         return response.text().then(text => {
                             throw new Error(`서버 응답 오류 (${response.status}): ${text || response.statusText}`);
                         });
                    }
                    return response.json();
                })
                .then(serverCounts => {
                    console.log("서버로부터 받은 예약 현황:", serverCounts);
                    updateReservationsFromCounts(serverCounts); // 로컬 객체 업데이트
                    localStorage.setItem('eventReservations', JSON.stringify(reservations)); // 로컬 스토리지 저장
                    console.log("로컬 스토리지 업데이트 완료.");
                    updateSlotStatus(); // 최신 정보로 UI 업데이트
                })
                .catch(error => {
                    console.error("최신 예약 현황 가져오기 실패:", error);
                    errorMessageEl.textContent = `예약 현황을 불러오는 중 오류가 발생했습니다: ${error.message}. 잠시 후 새로고침하거나 관리자에게 문의하세요.`;
                    errorModal.classList.remove('hidden');
                    // 오류 시에도 로컬 스토리지 기반으로 일단 그림 (기존 동작 유지)
                    reservations = JSON.parse(localStorage.getItem('eventReservations')) || initializeReservationsObject();
                    updateSlotStatus();
                })
                .finally(() => {
                    console.log("예약 현황 업데이트 로직 완료.");
                    document.body.style.cursor = 'default';
                    disableAllSlotsTemporarily(false); // 슬롯 다시 활성화
                });
        }

        fetchAndUpdateCounts(); // 페이지 로드 시 실행


        // --- 이벤트 리스너들 ---

        // 날짜 탭 클릭 (기존과 동일)
        // ...

        // 시간 슬롯 클릭 (기존과 동일, 비활성화 시 return 추가)
        document.querySelectorAll('.time-slot').forEach(slot => {
            slot.addEventListener('click', function() {
                // 비활성화 상태거나 로딩 중(opacity-50)이면 클릭 무시
                if (this.classList.contains('disabled') || this.classList.contains('opacity-50')) {
                    return;
                }
                // ... (나머지 클릭 로직 동일) ...
                // 이전 선택 해제
                document.querySelectorAll('.time-slot.selected').forEach(s => {
                    s.classList.remove('selected');
                });
                // 현재 슬롯 선택
                this.classList.add('selected');

                const date = this.getAttribute('data-date');
                const time = this.getAttribute('data-time');

                document.getElementById('selectedDate').value = date;
                document.getElementById('selectedTime').value = time;
                document.getElementById('selectedDateTime').value = `${date} ${time}`;
                document.getElementById('timeSelectionError').classList.add('hidden');
            });
        });

        // 폼 유효성 검사 함수 (validateForm) - 연락처 패턴 수정 및 개선
        function validateForm() {
            let isValid = true;
            // 오류 메시지 초기화
             document.querySelectorAll('.text-red-500.text-sm').forEach(el => el.classList.add('hidden'));
             document.querySelectorAll('.field-error').forEach(el => el.classList.remove('field-error'));

            // 시간 선택 확인
            const selectedDate = document.getElementById('selectedDate').value;
            const selectedTime = document.getElementById('selectedTime').value;
            if (!selectedDate || !selectedTime) {
                document.getElementById('timeSelectionError').classList.remove('hidden');
                isValid = false;
            }

            // 이름 확인
            const nameInput = document.getElementById('name');
            if (!nameInput.value.trim()) {
                document.getElementById('nameError').textContent = '이름을 입력해주세요.'; // 명확한 메시지
                document.getElementById('nameError').classList.remove('hidden');
                nameInput.classList.add('field-error');
                isValid = false;
            }

            // 이메일 확인
            const emailInput = document.getElementById('email');
            const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailInput.value.trim()) {
                document.getElementById('emailError').textContent = '이메일 주소를 입력해주세요.';
                document.getElementById('emailError').classList.remove('hidden');
                emailInput.classList.add('field-error');
                isValid = false;
            } else if (!emailPattern.test(emailInput.value.trim())) {
                document.getElementById('emailError').textContent = '유효한 이메일 형식이 아닙니다.';
                document.getElementById('emailError').classList.remove('hidden');
                emailInput.classList.add('field-error');
                isValid = false;
            }

            // 연락처 확인 (하이픈 제거 후 숫자 10~11자리 확인)
            const phoneInput = document.getElementById('phone');
            const phoneValue = phoneInput.value.replace(/-/g, '').trim(); // 하이픈 제거 및 공백 제거
            const phonePattern = /^(01[016789])?\d{7,8}$/; // 010/011 등 포함, 7~8자리 숫자

            if (!phoneValue) {
                document.getElementById('phoneError').textContent = '연락처를 입력해주세요.';
                document.getElementById('phoneError').classList.remove('hidden');
                phoneInput.classList.add('field-error');
                isValid = false;
            } else if (!phonePattern.test(phoneValue)) {
                document.getElementById('phoneError').textContent = "유효한 연락처 형식이 아닙니다 ('-' 없이 숫자만 입력).";
                document.getElementById('phoneError').classList.remove('hidden');
                phoneInput.classList.add('field-error');
                isValid = false;
            }

            // 개인정보 동의 확인
            const consentInput = document.getElementById('consent');
            if (!consentInput.checked) {
                document.getElementById('consentError').classList.remove('hidden');
                const consentBox = consentInput.closest('div.bg-gray-50') || consentInput; // 부모 div 찾기
                consentBox.classList.add('shake');
                setTimeout(() => consentBox.classList.remove('shake'), 500);
                isValid = false;
            }

            // 첫번째 오류 필드로 포커스 이동 (개선)
            if (!isValid) {
                 // 오류가 있는 요소들을 순서대로 찾음 (시간 > 이름 > 이메일 > 연락처 > 동의)
                 const errorElements = [
                     document.getElementById('timeSelectionError'),
                     document.getElementById('nameError'),
                     document.getElementById('emailError'),
                     document.getElementById('phoneError'),
                     document.getElementById('consentError')
                 ];
                 let firstErrorControl = null;

                 for (const errorMsgEl of errorElements) {
                     if (!errorMsgEl.classList.contains('hidden')) {
                         if (errorMsgEl.id === 'timeSelectionError') {
                            // 시간 선택은 특정 input이 아니므로 스크롤만 위로
                            errorMsgEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            firstErrorControl = errorMsgEl; // 포커스는 못하지만 식별용
                            break;
                         } else if (errorMsgEl.id === 'consentError') {
                             firstErrorControl = document.getElementById('consent');
                         } else {
                            // 이름, 이메일, 연락처는 해당하는 input 찾기
                            const inputId = errorMsgEl.id.replace('Error', '');
                            firstErrorControl = document.getElementById(inputId);
                         }
                         break; // 첫 오류 찾으면 중단
                     }
                 }

                 // 실제 포커스 가능하면 포커스 및 스크롤
                 if (firstErrorControl && typeof firstErrorControl.focus === 'function') {
                     firstErrorControl.focus();
                     // 스크롤은 포커스 시 자동으로 되지만, 명시적으로 호출할 수도 있음
                     // firstErrorControl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                 } else if (firstErrorControl) { // 포커스 불가능한 요소(div 등)는 스크롤만
                     firstErrorControl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                 }

                 // 폼 전체 흔들기 효과는 유지
                 form.classList.add('shake');
                 setTimeout(() => form.classList.remove('shake'), 500);
             }

            return isValid;
        }


        // 폼 제출 이벤트 리스너 (fetch 로직 개선 포함)
        form.addEventListener('submit', function(e) {
            e.preventDefault(); // 기본 제출 동작 방지

            if (!validateForm()) return; // 유효성 검사 실패 시 중단

             if (!SCRIPT_URL || SCRIPT_URL === '여기에_배포된_웹_앱_URL을_붙여넣으세요') {
                 console.error("스크립트 URL이 설정되지 않았습니다! 폼 제출 불가.");
                 errorMessageEl.textContent = "시스템 설정 오류로 예약을 처리할 수 없습니다. 관리자에게 문의하세요. (URL 미설정)";
                 errorModal.classList.remove('hidden');
                 return; // 함수 종료
             }

            // 제출 버튼 비활성화 및 스피너 표시
            submitButton.disabled = true;
            submitButtonText.textContent = '예약 처리 중';
            submitSpinner.classList.remove('hidden');

            // 전송할 데이터 객체 생성 (연락처는 하이픈 제거된 값 사용)
            const reservationData = {
                selectedDate: document.getElementById('selectedDate').value,
                selectedTime: document.getElementById('selectedTime').value,
                name: document.getElementById('name').value.trim(),
                email: document.getElementById('email').value.trim(),
                phone: document.getElementById('phone').value.replace(/-/g, '').trim() // 하이픈 제거된 값
            };

            console.log("서버로 전송할 데이터:", reservationData);

            // fetch API로 데이터 전송
            fetch(SCRIPT_URL, {
                method: 'POST',
                // mode: 'cors', // CORS 모드 명시 (필요한 경우)
                headers: {
                    // 'Content-Type': 'text/plain;charset=utf-8', // Apps Script는 text/plain도 잘 받음
                    'Content-Type': 'application/json' // JSON으로 명시
                },
                body: JSON.stringify(reservationData) // 데이터를 JSON 문자열로 변환
            })
            .then(response => {
                 // 응답 상태 코드로 1차 확인 + JSON 파싱 시도
                 if (!response.ok) {
                     // 서버 응답 본문을 JSON으로 읽어 에러 메시지 추출 시도
                     return response.json().then(errData => {
                          // 서버가 보낸 에러 메시지(errData.message)가 있으면 사용, 없으면 기본 상태 텍스트 사용
                          throw new Error(errData.message || `서버 응답 오류 (${response.status} ${response.statusText})`);
                     }).catch(jsonError => {
                         // JSON 파싱 실패 시 (응답이 JSON이 아닐 경우) 원본 상태 텍스트 사용
                         console.error("서버 에러 응답 JSON 파싱 실패:", jsonError);
                         throw new Error(`서버 응답 오류: ${response.status} ${response.statusText}`);
                     });
                 }
                 // 응답이 정상이면 JSON으로 파싱
                 return response.json();
            })
            .then(data => {
                console.log('Google Apps Script 응답:', data);
                if (data && data.result === "success") {
                    // --- 성공 처리 ---
                    const date = reservationData.selectedDate;
                    const time = reservationData.selectedTime;

                    // 로컬 데이터 즉시 업데이트 (기존 로직 유지 - UX 개선)
                    if (reservations.hasOwnProperty(date) && reservations[date].hasOwnProperty(time)) {
                         reservations[date][time].push(null); // 더미 예약 추가
                         localStorage.setItem('eventReservations', JSON.stringify(reservations)); // 로컬 스토리지 업데이트
                         updateSlotStatus(); // UI 즉시 업데이트
                    } else {
                        console.warn(`예약 성공 응답 받았으나 로컬 데이터 구조에 해당 슬롯(${date} ${time})이 없어 즉시 업데이트 불가`);
                        // 서버 동기화를 위해 fetchAndUpdateCounts() 호출 고려 가능
                        // fetchAndUpdateCounts(); // 필요시 주석 해제 (네트워크 요청 추가 발생)
                    }

                    // 성공 모달 표시
                    successMessageEl.textContent = `${formatDate(date)}, ${time} 시간대에 예약이 성공적으로 완료되었습니다.`;
                    successModal.classList.remove('hidden');
                    resetForm(); // 폼 초기화
                } else {
                    // Apps Script가 result:"error" 반환 (예: 중복, 마감 등 서버 로직상 에러)
                    throw new Error(data.message || '알 수 없는 서버 오류가 발생했습니다.');
                }
            })
            .catch(error => {
                // 네트워크 오류 또는 then 체인 내에서 발생한 모든 오류 처리
                console.error('폼 제출 또는 응답 처리 중 오류:', error);
                errorMessageEl.textContent = `예약 처리 중 오류가 발생했습니다: ${error.message}. 잠시 후 다시 시도해주세요.`;
                errorModal.classList.remove('hidden');
                 // 오류 발생 시 최신 상태 반영을 위해 서버 카운트 다시 가져오기 (선택적)
                 fetchAndUpdateCounts();
            })
            .finally(() => {
                // 버튼 다시 활성화 및 스피너 숨김
                submitButton.disabled = false;
                submitButtonText.textContent = '예약하기';
                submitSpinner.classList.add('hidden');
            });
        });


        // 날짜 형식 변환 함수 (formatDate) - 기존과 동일
        function formatDate(dateString) {
             // ... (기존 로직 동일) ...
             try {
                 const date = new Date(dateString + 'T00:00:00Z'); // UTC 기준으로 파싱하여 시간대 문제 최소화
                 const year = date.getFullYear();
                 const month = date.getMonth() + 1;
                 const day = date.getDate();
                 // getDay()는 로컬 시간 기준 요일을 반환하므로, UTC 날짜 객체에는 부적합할 수 있음.
                 // 더 정확하려면 날짜 라이브러리(예: date-fns, dayjs) 사용 고려. 간단히 로컬 기준으로 표시.
                 const dayOfWeek = ['일', '월', '화', '수', '목', '금', '토'][new Date(dateString).getDay()]; // 로컬 기준 요일
                 return `${year}년 ${month}월 ${day}일 (${dayOfWeek})`;
             } catch (e) {
                 console.error("날짜 형식 변환 오류:", dateString, e);
                 return dateString; // 오류 시 원본 반환
             }
         }

        // 폼 초기화 함수 (resetForm) - 기존과 동일
        function resetForm() {
            // ... (기존 로직 동일) ...
             form.reset();
             document.getElementById('selectedDate').value = '';
             document.getElementById('selectedTime').value = '';
             document.getElementById('selectedDateTime').value = '';
             document.querySelectorAll('.time-slot.selected').forEach(s => s.classList.remove('selected'));
             form.querySelectorAll('.text-red-500.text-sm').forEach(el => el.classList.add('hidden'));
             form.querySelectorAll('.field-error').forEach(el => el.classList.remove('field-error'));
             // 첫번째 날짜 탭을 다시 활성화 (선택적)
             const firstTab = document.querySelector('.date-tab');
             if (firstTab) firstTab.click();
        }

        // 모달 닫기 이벤트 (기존과 동일)
        document.querySelectorAll('.close-modal').forEach(button => {
            button.addEventListener('click', function() {
                this.closest('.fixed.inset-0.flex').classList.add('hidden');
            });
        });

    });
</script>
</body>
</html>
